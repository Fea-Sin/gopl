

### Slice 切片

Slice（切片）代表变长的序列，序列中每个元素都有相同的类型，一个slice类型一般写作[]T，其中T代表
slice中元素的类型，slice语法和数组很像，只是没有固定长度而已。

数组和slice之间有着紧密的联系，一个slice是一个轻量级的数据结构，提供了访问数组子序列（或这全序列）
元素的功能，而且slice的底层确实引用了一个数组对象。一个slice由三个部分构成：指针、长度和内容，指针
指向第一个slice元素对应的底层数组元素的地址，长度对应slice中元素的数目，长度不能超过容量，容量一般
是从slice的开始位置到底层数据的结尾位置。内置的`len`和`cap`函数分别返回slice的长度和容量。


slice的切片操作s[i:j]，其中0 <= i <= j <= cap(s)，用于创建一个新的slice，应用s的从第i个元素
到j-1个元素的子序列，新的slice只有j-i个元素。如果i位置的索引被省略的话将使用0代替，如果j位置的索引
被省略的话将使用len(s)代替。

如果切片操作超出cap(s)的上限将导致一个panic异常，但是超出len(s)则是意味着扩展slice，因为新slice
的长度会变大

另外，字符串的切片操作和[]byte字节类型切片的切片操作是类似的，都写作x[m:n]，并且都是返回一个原始字节
系列的子序列，底层都是共享之前的底层数组，因此这种操作都是常量时间复杂度。x[m:n]切片操作对于字符串则
生成一新的字符串，如果x是[]byte的话则生成一个新的[]byte。

因为slice值包含指向第一个slice元素的指针，因此向函数传递slice并对slice做修改时是修改底层的数组的元素。


### 数组

数组是一个固定长度的特定类型元素组成的序列，一个数组可以由零个或多个元素组成，因为数组
的长度是固定的，因此在Go语言中很少直接使用数组，和数组对应的类型是Slice（切片），它
是可以增长和收缩的动态序列，slice功能也更灵活，但是要理解slice工作原理需要先理解
数组。

数组的每个元素可以通过索引下标来访问，索引下标的范围是从0开始到数组长度减1的位置。
内置len函数将返回数组中元素的个数
```
var a [3]int

a[0]

a[len(a)-1]

for i, v := range a {
    fmt.Printf("%d %d\n", i, v)
}
```

默认情况下，数组的每个元素被初始化为元素类型对应的零值。

在数组字面值中，如果在数组的长度位置出现的是"..."省略号，则表示数组的长度是根据初始化
值的个数来计算
```
q := [...]int{1, 2, 3}
fmt.Printf("%T\n", q) // "[3]int"
```

数组的长度是数组类型的一个组成部分，数组长度必须是常量表达式，因此数组的长度需要在
编译阶段确定。

我们发现数组、slice、map和结构体字面量的写法都很相似，上面的形式是提供顺序初始化
值序列，但是也可以指定一个索引和对应值列表的方式初始化
```
type Currency int

const (
    USD Currency = iota // 美元
    EUR                 // 欧元
    GBP                 // 英镑
    RMB                 // 人民币
)

symbol := [...]string{USD: "$", EUR: "€", GBP: "￡", RMB: "¥"}
fmt.Println(RMB, symbol[RMB]) // "3 ¥"

```
























