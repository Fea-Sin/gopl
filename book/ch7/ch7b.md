
### 函数值

在Go中，函数被看作第一类值（first-class values）函数像其他值一样拥有类型，可以被赋值
给其他变量，传递给函数，从函数中返回。对函数值的调用类似函数调用。

[实例](gb.go)

函数类型的零值是nil，调用值为nil的函数值会引起`panic`错误

函数值可以与nil比较，但是函数值之间是不能比较的，也不能用函数值作为map的key
```
var f func(int) int
if f != nil {
    f(3)
}
```

### 匿名函数

拥有函数名的函数只能在包级语法块中被声明。通过函数字面量（function literal），我们
可以绕过这一限制，在任何表达式中表示一个函数值。函数字面量的语法和函数声明相似，区别
在于func关键字后没有函数名，函数字面量是一种表达式，它的值被称为匿名函数（anonymous
function）。

更为重要的是匿名函数可以访问完整的词法环境（lexical environment），这意味这着在
函数中定义的匿名函数可以引用函数的变量。

[实例1](gfa.go)
函数squares返回另一个类型为func() int的函数，对squares的一次调用会生成一个局部
变量x并返回一个匿名函数，每次调用匿名函数时，该函数都会先使x的值加1，再返回x的平方，
第二次调用squares时，会生成第二个x变量，并返回一个新的匿名函数，新匿名函数操作的是
第二个x变量。

在squares中定义的匿名内部函数可以访问和更新squares中的局部变量，这意味着匿名函数
引用squares中的变量，这就是函数值属于引用类型和函数值不可比较的原因。Go使用闭包
技术实现函数值，Go程序员也把函数值叫做闭包。

通过这个例子，我们看到变量的生命周期不由它的作用域决定，squares返回后变量x仍然隐式
的存在于f中。

#### 拓扑排序

[实例2](gfb.go)

从概念上讲，前置条件可以构成有向图，图中的顶点表示课程，边表示课程间的依赖关系，显然，
图中应该无环，这也就是说从某点出发的边，最终不会回到该点，实例代码用**深度优先**
搜索了整张图

下面函数实现了广度优先算法，调用者需要输入一个初始的待访问列表和一个函数f，待访问
列表中的每个元素被定义为string类型，广度优先算法会为每个元素调用一次f，每次f执行
完毕后，会返回一组待访问元素，这些元素会被加入到待访问列表中，当待访问列表中的所有
元素都被访问后，breadthFirst函数运行结束。

[实例3](gfc.go)















