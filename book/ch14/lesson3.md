

### 接口值

概念上讲一个接口的值，接口值由两部分组成，一个具体的类型和那个类型的值。它们
被称为接口的动态类型和动态值。对于像Go语言这种静态类型的语言，类型是编译期的
概念，因此一个类型不是一个值。在我们的概念模型中，一些提供每个类型信息的值被称
为类型描述符，比如类型的名称和方法，在一个接口值中，类型部分代表与之相关类型
的描述符。

在Go语言中，变量总是被一个定义明确的值初始化，即使接口类型也不例外，对于一个接口
的零值就是它的类型和值的部分都是nil。

```
var w io.Writer
```
一个接口值基于它的动态类型被描述为空或非空，这是一个空的接口值，
调用一个空接口值上的任意方法都会产生panic。

```
w = os.Stdout
```
这个赋值过程调用了一个具体类型到接口类型的隐式转换，这个接口值的**动态类型**被设为
`*os.File`指针的类描述符，它的**动态值**持有os.Stdout的拷贝，这是一个代表
处理标准输出的os.File类型变量的指针。
```
w.Write([]byte("hello"))  // "hello"
```
调用一个包含`*os.File`类型指针的接口值的Write方法，使得`(*os.File).Write`方法
被调用。
```
w = new(bytes.Buffer)
```
现在动态类型是`*bytes.Buffer`并且动态值是一个指向新分配的缓冲区的指针。
```
w.Write([]byte("hello")) // writes "hello" to the bytes.Buffers
```
这次类型描述符是`*bytes.Buffer`，所以调用了(*bytes.Buffer).Write方法，
并且接收者是该缓冲地区的地址，这个调用把字符串"hello"添加到缓冲区中。

```
w = nil
```
这个重置将它所有的部分都设为nil值，把变量w恢复到和它之前定义相同的状态。

接口值可以使用==和!=来进行比较，两个接口值相等仅当它们都是nil值，或者它们的动态
类型相同并且动态值也根据这个动态类型的==操作相等，因为接口值是可比较的，所以它们
可以用在map的键或者作为switch语句的操作数。

如果两个接口值的动态类型相同，但是这个动态类型是不可比较的（比如切片），将它们进行
比较就会失败且panic。只能比较你非常确定它们的动态值是可比较类型的接口值。

当我们处理错误或者调试的过程中，得知接口值的动态类型是非常有帮助的，所以我们使用
fmt包的%T动作。在fmt包内部，使用反射来获取接口动态类型的名称。













