

### 方法

在函数声明时，在其名字之前放上一个变量，即是一个方法。这个附加的参数会将该函数
附加到这种类型上，即相当于为这种类型定义了一个独占的方法。

```
type Point struct{X, Y float64}

// 传统的方法
func Distance(p, q Point) float64 {
    return math.Hypot(q.X - p.X, q.Y - p.Y)
}

// 方法
func (p Point) Distance(q Point) float64 {
    return math.Hypot(q.X - p.X, q.Y - p.Y)
}
```
上面的代码里那个附加的参数p，叫做方法的接收器（receiver），早期的面向对象语言
将调用一个方法称为：向一个对象发送消息。

在Go语言种我们并不会像其它语言那样用this或者self作为接收器，我们可以任意的选择
接收器的名字，由于接收器的名字经常被用到，所以保持其在方法间传递的一致性和简短
性是必要的，建议可以使用其类型的第一个字母，比如这里使用了Point的首字母p。

接收器参数在方法名之前调用方法
```
p := Point{1, 2}
q := Point{4, 6}

// 函数调用
Distance(p, q)
// 方法调用
p.Distance(q)
```

上面的两个函数调用的都是Distance，但是却没有发生冲突，第一个Distance的调用
实际上是包级别函数Distance，第二个是Point类下声明的Point.Distance方法。

这种p.Distance的表达式叫做选择器，它会选择合适的对应p这个对象的Distance
方法来执行，选择器也会被用来选择一个struct类型的字段，比如p.X，由于方法和
字段都是在同一命名空间，所以如果我们在这里声明一个X方法的话，编译器会报错。

[实例1](ga.go)
在上面两个对Distance名字的方法调用中，编译器会根据方法的名字以及接收器来决定
具体调用的是哪一个函数。

对于一个给定的类型，其内部的方法都必须有唯一的方法名，但是不同的类型却可以有
同样的方法名。

### 基于指针对象的方法

当调用一个函数时，会对其每一个参数值进行拷贝，如果一个函数需要更新一个变量，或者
函数的其中一个参数实在太大我们希望能够避免进行这种默认的拷贝，这种情况下我们就
需要用到指针了。

当定义方法时，接收器变量本身比较大时，我们就可以用指针而不是对象来声明方法。
```
func (p *Point) ScaleBy(factor float64) {
    p.X *= factor
    p.Y *= factor
}
```
这个方法的名字是`(*Point).ScaleBy`，这里的括号是必须的，没有括号这个表达式
可能被理解为`*(Point.ScaleBy)`。

只有类型（Point）和指向他们的指针（*Point），才可能出现在接收器声明中，如果
一个类型名本身是一个指针的话，是不允许出现在接收器中的。
```
type P *int
func (P) f() {}   // compile error: invalid receiver type
```

想调用指针类型方法`(*Point).ScaleBy`，只需要提供一个Point类型的指针即可
```
// 1
r := &Point{1, 2}
r.ScaleBy(2)

// 2
p := Point{1, 2}
pptr := &p
pptr.ScaleBy(2)

// 3
p := Point{1, 2}
(&p).ScaleBy(2)
```

幸运的是，不论接收器的实际参数和其形式参数，比如接收器是类型`*T`，但调用时
使用类型T，编译器会隐式地为我们取变量地址
```
p.ScaleBy(2) // implicat (&p)
```
接收器是T，但调用时使用*T，编译器会隐式地为我们用解引用符号解引
```
pptr.Distance(q) // implicat (*pptr)
```

如果命名类型T（用type xxx定义的类型）的所有方法都是用T类型做接收器（而不是*T），
那么拷贝这种类型的实例就是安全的，调用他的任何一个方法也就会产生一个值的拷贝。
但是一个方法使用指针作为接收器，你需要避免对其进行拷贝，因为这可能会破坏掉该类型
内部的不变性。比如你对bytes.Buffer对象进行拷贝，拷贝对象只是原始对象的别名而已，
实际上它们指向的对象是一样的，如果对拷贝对象进行修改可能会有让你意外的结果。

**总结**，在声明一个method的receiver该是指针还是非指针类型时，你需要考虑两
方面的因素，第一方面是这个对象是不是特别大，如果声明为非指针变量时，调用会
产生一次拷贝；第二方面是如果你用指针类型为为receiver，那么一定要注意这种指针
类型指向的始终是一块内存地址。

[实例2](gb.go)
由于url.Values是一个map类型，并且间接引用了其key/value对，因此url.Values.Add
对这个map里的元素做任何的更新、删除操作对调用方来说都是可见的。实际上，就像在
普通函数中一样，虽然可以通过引用操作内部值，但在方法想要修改本身时是不会影响
原始值的。（因为传入的是存储了内存地址的变量，你改变这个变量是影响不了原始值的）





















