
## 并发的非阻塞缓存

本节我们会做一个无阻塞的缓存，这种工具可以帮助我们来解决现实世界中并发程序出现
但没有现成库可以解决的问题。这个问题叫做（memoizing）函数（Memoization的
定义：memoization一词是Donald Michie根据拉丁语memorandum杜撰的一个词），
也就是说，我们需要缓存函数的返回结果，这样在对函数进行调用的时候，我们就只需要
一次计算，之后只要返回计算的结果就可以了。我们的解决方案是并发安全且会避免对整个
缓存枷锁而导致所有操作都去争一个锁的设计。

我们将使用httpGetBody函数作为我们需要缓存的函数的一个样例，这个函数会去进行
HTTP GET请求且获取http响应body，这个函数的调用本身开销是比较大的，所以我们
尽量避免在不必要的时候反复调用。

```
func httpGetBody(url string) (interface{}, error) {
    resp , err := http.Get(url)
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()
    return ioutil.ReadAll(resp.Body)
}
```

[cache实例1](memo1/memo.go) 并不是并发安全的

并发、不重复请求、无阻塞的缓存

[使用锁来建立并发](memo2/memo.go)

[使用通信来建立并发](memo3/memo.go)

### Goroutines 和 线程

每一个OS线程都有一个固定大小的内存块（一般会是2MB）来做栈，这个栈会用来存储
当前正在被调用或挂起（指在调用其它函数时）的函数的内部变量。这个固定大小的栈
同时很大有很小，因为2MB的栈对于一个小小的goroutine来说是很大的内存浪费，比如
对于我们用到的，一个只是用来WaitGroup之后关闭channel的goroutine来说。而
对于Go程序来说，同时创建成百上千个goroutine是非常普遍的，如果每一个goroutine
都需要这么大的栈的话，那么多的goroutine就不太可能了。修改固定的大小可以提升
空间的利用率，允许创建更多的线程，并且可以允许更深的递归调用，不过这两者是没办法
同时兼备的。

相反，一个goroutine会以一个很小的栈开始其声明周期，一般只需要2KB，一个goroutine
的栈，和操作系统线程一样，会保存其活跃和挂起的函数调用的本地变量，但是和OS线程
不太一样的是，一个goroutine的栈大小并不是固定的，栈的大小会根据需要动态地伸缩，
而goroutine的栈的最大值有1GB，比传统的固定大小的线程要大得多，尽管一般情况下，
大多goroutine都不需要这么大的栈。

### Goroutine 调度

OS线程会被操作系统内核调度，每几毫秒，一个硬件计时器会中断处理器，这会调用一个
叫作scheduler的内核函数，这个函数会挂起当前执行的线程并将它的寄存器内容保存
到内存中，检查线程列表并决定下一次哪个线程可以被运行，并从内存中恢复该线程的寄存器
信息，然后恢复执行该线程的现场并开始执行线程。因为操作系统线程是被内核所调度，
所以从一个线程向另一个"移动"需要完整的上下文切换，也就是说，保存一个用户线程
状态到内存，恢复另一个线程到寄存器，然后更新调度器的数据结构。这记不操作很慢，因为
局部性很差需要几次内存访问，并且会增加运行的cpu周期。

Go的运行时包含了其自己的调度器，这个调度器使用了一些技术手段，比如m:n调度，因为
其会在n个操作系统线程上多工调度m个goroutine。Go调度器的工作和内核的调度是相似
的，但是这个调度器只关注单独的Go程序中的goroutine。

和操作系统的线程调度不同的是，Go调度器并不是一个硬件定时器，而是被Go语言建筑本身
进行调度的。例如当一个goroutine调用了time.Sleep，或者被channel调用或者
mutex操作阻塞时，调度器会使其进入休眠并开始执行另一个goroutine，直到时机
到了再去唤醒第一个goroutine。因为这种调度方式不需要进入内核的上下文，所以重新
调度一个goroutine比调度一个线程代价低得多。

### GOMAXPROCS

Go的调度器使用了一个叫做GOMAXPROCS的变量来决定会有几个操作系统的线程同时执行
Go的代码。其默认的值是运行机器上的CPU的核心数，所以在一个8个核心的机器上时，
调度器一次会在8个OS线程上去调度GO代码，（GOMAXPROCS是前面说的m:n调度中的n）。
在休眠中的或者在通信中被阻塞的goroutine是不需要一个对应的线程来调度的，在I/O
中或系统调用中或调用非Go语言函数时，是需要一个对应的操作系统线程的，但是
GOMAXOCS并不需要将这几种情况计算在内。

### Goroutine 没有ID号

在大多数支持多线程的操作系统和程序语言中，当前的线程都有一个独特的身份ID，并且
这个身份信息可以以一个普通值的形式被很容易地获取到，典型的可以是一个integer
或者指针值。

goroutine没有可以被程序员获取到的身份ID的概念，这一点是设计上故意为之，由于
thread-local storage总是会被滥用。

Go鼓励更为简单的模式。



















