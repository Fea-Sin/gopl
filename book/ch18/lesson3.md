

## sync.RWMutex 读写锁

Bob写了一个程序，每秒云心几百次来检查他的银行余额，银行注意到这些陡增的流量使得存款和取款
有了延时，因为所有的余额查询请求是顺序执行的，这样会互斥地获得锁，并且会暂时阻止其他的
goroutine运行。

由于Balance函数只需要读取变量的值，所以我们同时让多个Balance调用并发运行事实上是安全的，
只要在查询的时候没有存款或取款操作就行。在这种场景下我们需要一种特殊类型的锁，其允许多个只
读操作并行执行，但写操作会完全互斥，这种锁叫作"多读单写"锁（multiple readers, single
writer lock），Go语言提供的这样的锁是sync.RWMutex
```
var mu sync.RWMutex
var balance int

func Balance() int {
    mu.RLock()
    defer mu.RUnlock()
    return balance
}
```
在这次修改后，Bob的余额查询请求就可以彼此并行地执行并且会很快地完成了，锁在更多的时间
范围可用，并且存款请求也能够及时地被响应了。

RLock只能在临界区共享变量没有任何写入操作时可用。一般来说，我们不应该假设逻辑上的只读
函数/方法也不会去更新某一些变量。比如一个方法功能是访问一个变量，但它也有可能会同时去
给一个内部计数器+1，可能是记录这个方法的访问次数啥的，或者去更新缓存，使即时调用
能够更快。这时请使用互斥锁。

### 内存同步

现在计算机中可能会有一堆处理器，每一个都会有其本地缓存（local cache），为了效率，对内存
的写入一般会在每一个处理器中缓冲，并在必要时一起flush到主存。这种情况下这些数据可能会以与当初
goroutine写入顺序不同的顺序被提交到主存。像channel通信或者互斥量操作这样的原语会使处理器
将其聚焦的写入flush并commit，这样goroutine在某个时间点上的执行结果才能被其他处理器上
运行的goroutine得到。

在一个独立的goroutine中，每一个语句的执行顺序是可以被保证的，也就是说goroutine内
顺序是连贯的。但是在不使用channel且不使用mutex这样的显式同步操作时，我们就没办法
保证事件在不同的goroutine中看到的执行顺序是一致的了。更有甚者，如果两个goroutine
在不同的CPU上执行，每一个核心有自己的缓存，这样一个goroutine的写入对于其他
goroutine的print，在主存同步之前就是不可见的了。

















